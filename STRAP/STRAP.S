REM  Strap compiler in 8086 assembly (BATAS dialect).
REM  We run over the input file twice: first to calculate the addresses of all
REM  labels, second to actually emit all the bytes in a single pass.
REM  While we don't adhere to a specific calling convention, we try to
REM  callee-preserve as many registers as possible.

CALL PUSH CS
CALL POP DS
CALL PUSH CS
CALL POP ES
CALL CLL %MAIN%
CALL INT 32

CALL LABEL PANICMSG
REM       P  a  n   i   c  $
  CALL DB 80 97 110 105 99 36
REM  Display error message and quit
CALL LABEL PANIC
  CALL PUSH CS
  CALL POP DS
  CALL MOV DX WORD %PANICMSG%
  CALL MOV AH BYTE 9
  CALL INT 33
  CALL INT 32
REM  Conditional jumps only have 8-bit displacement so if we'd like to panic
REM  on carry, we have call one of these trampolines.
CALL LABEL JC_PANIC
  CALL JC %PANIC%
  CALL RET
CALL LABEL JE_PANIC
  CALL JE %PANIC%
  CALL RET

REM  This is a simplistic sequential allocator with no way to free memory
REM  The memory comes from the area between the executable code (HEAPSTART is
REM  defined at the very end of the executable) and the stack.
CALL LABEL HEAPPTR
  CALL DW 0%HEAPSTART%
REM  Number of bytes in AX. Returns offset against CS in AX.
CALL LABEL ALLOC
  CALL PUSH CX
  CALL MOV CX [WORD] %HEAPPTR%
  CALL ADD [WORD] %HEAPPTR% AX
  CALL MOV AX CX
  CALL POP CX
  CALL RET

REM  Compute the length of the string in AX, including the NUL terminator.
REM  Output in CX.
CALL LABEL STRSIZE
  CALL PUSH AX
  CALL PUSH SI
  CALL PUSH DI
  CALL MOV SI AX
  CALL MOV DI AX
  CALL XOR CX CX
  CALL NOT CX
  CALL XOR AL AL
  CALL REPNE SCASB
  CALL NOT CX
  CALL POP DI
  CALL POP SI
  CALL POP AX
  CALL RET

REM  String pointer in AX. Returns pointer to copy in AX.
CALL LABEL STRDUP
  CALL PUSH CX
  CALL PUSH SI
  CALL PUSH DI
  CALL CLL %STRSIZE%
  CALL MOV SI AX
  CALL MOV AX CX
  CALL CLL %ALLOC%
  CALL MOV DI AX
  CALL REP MOVSB
  CALL POP DI
  CALL POP SI
  CALL POP CX
  CALL RET

REM  Global variables containing file handles for the input and output files.
CALL LABEL IN_HANDLE
  CALL DW 0
CALL LABEL OUT_HANDLE
  CALL DW 0

REM  Are we just calculating offsets (0) or actually emitting bytes (1)?
CALL LABEL EMIT_MODE
  CALL DB 0
REM  Current value of the Instruction Pointer. In COM this starts at 0x100.
CALL LABEL CUR_IP
  CALL DW 0
CALL LABEL BUFFER
  CALL DB 0
REM  Emit (depending on EMIT_MODE) a single byte in AL to the output handle.
CALL LABEL EMIT_BYTE
  CALL INC WORD [WORD] %CUR_IP%
  CALL CMP [WORD] %EMIT_MODE% BYTE 0
  CALL JE %EMIT_BYTE_SKIP%
  CALL PUSH AX
  CALL PUSH CX
  CALL PUSH DX
  CALL PUSH BX
  CALL MOV [WORD] %BUFFER% AL
  CALL MOV BX [WORD] %OUT_HANDLE%
  CALL MOV DX WORD %BUFFER%
  CALL MOV CX WORD 1
  CALL MOV AH BYTE 64
  CALL INT 33
  CALL CLL %JC_PANIC%
  CALL POP BX
  CALL POP DX
  CALL POP CX
  CALL POP AX
  CALL LABEL EMIT_BYTE_SKIP
  CALL RET
REM  Emit a word in AX.
CALL LABEL EMIT_WORD
  CALL CLL %EMIT_BYTE%
  CALL XCHG AL AH
  CALL CLL %EMIT_BYTE%
  CALL XCHG AL AH
  CALL RET
REM  Emit an array. Pointer to beginning in AX, byte size in CX.
CALL LABEL EMIT_ARRAY
  CALL PUSH AX
  CALL PUSH CX
  CALL PUSH BX
  CALL MOV BX AX
  CALL LABEL EMIT_ARRAY_LOOP
  CALL TEST CX CX
  CALL JZ %EMIT_ARRAY_END%
  CALL MOV AL [BX]
  CALL INC BX
  CALL DEC CX
  CALL CLL %EMIT_BYTE%
  CALL JMP %EMIT_ARRAY_LOOP%
  CALL LABEL EMIT_ARRAY_END
  CALL POP BX
  CALL POP CX
  CALL POP AX
  CALL RET

REM  A function to read a single character from the input handle with support 
REM  for "unreading" a character once.
CALL LABEL UNPEEKED
  CALL DB 0
CALL LABEL IS_UNPEEKED
  CALL DB 0
REM  Returns the character in AL.
CALL LABEL PEEK
  CALL CMP [WORD] %IS_UNPEEKED% BYTE 0
  CALL JE %PEEK_READ%
  CALL MOV [WORD] %IS_UNPEEKED% BYTE 0
  CALL MOV AL [WORD] %UNPEEKED%
  CALL CBW
  CALL RET
  CALL LABEL PEEK_READ
  CALL PUSH CX
  CALL PUSH DX
  CALL PUSH BX
  CALL MOV BX [WORD] %IN_HANDLE%
  CALL MOV [WORD] %BUFFER% BYTE 0
  CALL MOV DX WORD %BUFFER%
  CALL MOV CX WORD 1
  CALL MOV AH BYTE 63
  CALL INT 33
  CALL CLL %JC_PANIC%
  CALL POP BX
  CALL POP DX
  CALL POP CX
  CALL MOV AL [WORD] %BUFFER%
  CALL CBW
  CALL RET
REM  The character is in AL.
CALL LABEL UNPEEK
  CALL CMP [WORD] %IS_UNPEEKED% BYTE 1
  CALL CLL %JE_PANIC%
  CALL MOV [WORD] %UNPEEKED% AL
  CALL MOV [WORD] %IS_UNPEEKED% BYTE 1
  CALL RET

REM  Read a proper number (decimal or hexadecimal) from the input handle.
REM  Returns the number in AX.
CALL LABEL READ_NUM
  CALL PUSH CX
  CALL PUSH DX
  CALL PUSH DI
  CALL MOV DI WORD 10
  CALL XOR CX CX
  CALL CLL %PEEK%
  CALL CMP AL BYTE 48
  CALL JNE %READ_NUM_IN%
  CALL CLL %PEEK%
  CALL CMP AL BYTE 88
  CALL JE %READ_NUM_HEX%
  CALL CMP AL BYTE 120
  CALL JE %READ_NUM_HEX%
  CALL JMP %READ_NUM_IN%
  
  CALL LABEL READ_NUM_LOOP
  CALL CLL %PEEK%
  CALL LABEL READ_NUM_IN
  CALL CMP AL BYTE 48
  CALL JB %READ_NUM_END%
  CALL CMP AL BYTE 58
  CALL JAE %READ_NUM_END%
  CALL SUB AL BYTE 48
  CALL CBW
  CALL XCHG AX CX
  CALL MUL DI
  CALL ADD AX CX
  CALL MOV CX AX
  CALL JMP %READ_NUM_LOOP%

  CALL LABEL READ_NUM_HEX
  CALL MOV DI WORD 16
  CALL CLL %PEEK%
  CALL CMP AL BYTE 48
  CALL JB %READ_NUM_END%
  CALL CMP AL BYTE 58
  CALL JAE %READ_NUM_LO%
  CALL SUB AL BYTE 48
  CALL JMP %READ_NUM_ADD%
  CALL LABEL READ_NUM_LO
  CALL CMP AL BYTE 65
  CALL JB %READ_NUM_END%
  CALL CMP AL BYTE 71
  CALL JAE %READ_NUM_HI%
  CALL SUB AL BYTE 55
  CALL JMP %READ_NUM_ADD%
  CALL LABEL READ_NUM_HI
  CALL CMP AL BYTE 97
  CALL JB %READ_NUM_END%
  CALL CMP AL BYTE 103
  CALL JAE %READ_NUM_END%
  CALL SUB AL BYTE 87
  CALL LABEL READ_NUM_ADD
  CALL CBW
  CALL XCHG AX CX
  CALL MUL DI
  CALL ADD AX CX
  CALL MOV CX AX
  CALL JMP %READ_NUM_HEX%

  CALL LABEL READ_NUM_END
  CALL CLL %UNPEEK%
  CALL MOV AX CX
  CALL POP DI
  CALL POP DX
  CALL POP CX
  CALL RET

REM  Checks whether AL is an identifier character. Sets CF if so.
CALL LABEL IS_IDENT
  CALL CMP AL BYTE 95
  CALL JE %IS_IDENT_YES%
  CALL CMP AL BYTE 48
  CALL JB %IS_IDENT_NO%
  CALL CMP AL BYTE 58
  CALL JB %IS_IDENT_YES%
  CALL CMP AL BYTE 65
  CALL JB %IS_IDENT_NO%
  CALL CMP AL BYTE 91
  CALL JB %IS_IDENT_YES%
  CALL CMP AL BYTE 97
  CALL JB %IS_IDENT_NO%
  CALL CMP AL BYTE 123
  CALL JB %IS_IDENT_YES%
  CALL LABEL IS_IDENT_NO
  CALL CLC
  CALL RET
  CALL LABEL IS_IDENT_YES
  CALL STC
  CALL RET

REM  Token type is either an ASCII code or one of these constants:
CALL EQU TK_NUM 256
CALL EQU TK_IDENT 257
CALL EQU TK_INCLUDE 258

REM  If the token was a number, this is where its numeric value would be
REM  stored.
CALL LABEL TOKEN_NUM
  CALL DW 0
REM  If the token was an identifier or an include directive, this is where its
REM  characters would be stored. Currently a fixed buffer of 128 bytes.
CALL LABEL TOKEN_STR
  CALL DW 0 0 0 0 0 0 0 0
  CALL DW 0 0 0 0 0 0 0 0
  CALL DW 0 0 0 0 0 0 0 0
  CALL DW 0 0 0 0 0 0 0 0
  CALL DW 0 0 0 0 0 0 0 0
  CALL DW 0 0 0 0 0 0 0 0
  CALL DW 0 0 0 0 0 0 0 0
  CALL DW 0 0 0 0 0 0 0 0
REM  Read a token from the input handle, returning the type in AX, with more
REM  information possibly in TOKEN_NUM or TOKEN_STR.
CALL LABEL READ_TOKEN
  CALL CLL %PEEK%
  CALL CMP AL BYTE 9
  CALL JE %READ_TOKEN%
  CALL CMP AL BYTE 10
  CALL JE %READ_TOKEN%
  CALL CMP AL BYTE 13
  CALL JE %READ_TOKEN%
  CALL CMP AL BYTE 32
  CALL JE %READ_TOKEN%
  CALL CMP AL BYTE 34
  CALL JE %READ_TOKEN_INCLUDE%
  CALL CMP AL BYTE 35
  CALL JE %READ_TOKEN_COMMENT%
  CALL CMP AL BYTE 39
  CALL JE %READ_TOKEN_CHAR%

  CALL CMP AL BYTE 48
  CALL JB %READ_TOKEN_AL%
  CALL CMP AL BYTE 58
  CALL JAE %READ_TOKEN_AL%
  CALL CLL %UNPEEK%
  CALL CLL %READ_NUM%
  CALL MOV [WORD] %TOKEN_NUM% AX
  CALL MOV AX WORD %TK_NUM%
  CALL RET

  CALL LABEL READ_TOKEN_COMMENT
  CALL CLL %PEEK%
  CALL CMP AL BYTE 10
  CALL JNE %READ_TOKEN_COMMENT%
  CALL JMP %READ_TOKEN%

  CALL LABEL READ_TOKEN_CHAR
  CALL CLL %PEEK%
  CALL CBW
  CALL MOV [WORD] %TOKEN_NUM% AX
  CALL MOV AX WORD %TK_NUM%
  CALL RET

  CALL LABEL READ_TOKEN_AL
  CALL CLL %IS_IDENT%
  CALL JNC %READ_TOKEN_SYM%
  CALL PUSH DI
  CALL MOV DI WORD %TOKEN_STR%
  CALL LABEL READ_TOKEN_IDENT
  CALL STOSB
  CALL CLL %PEEK%
  CALL CLL %IS_IDENT%
  CALL JC %READ_TOKEN_IDENT%
  CALL CLL %UNPEEK%
  CALL XOR AL AL
  CALL STOSB
  CALL POP DI
  CALL MOV AX WORD %TK_IDENT%
  CALL RET

  CALL LABEL READ_TOKEN_INCLUDE
  CALL PUSH DI
  CALL MOV DI WORD %TOKEN_STR%
  CALL LABEL READ_TOKEN_INCL_LOOP
  CALL CLL %PEEK%
  CALL CMP AL BYTE 34
  CALL JE %READ_TOKEN_INCL_END%
  CALL STOSB
  CALL JMP %READ_TOKEN_INCL_LOOP%
  CALL LABEL READ_TOKEN_INCL_END
  CALL XOR AL AL
  CALL STOSB
  CALL POP DI
  CALL MOV AX WORD %TK_INCLUDE%
  CALL RET

  CALL LABEL READ_TOKEN_SYM
  CALL RET

REM  A singly linked list of labels. A label is a 3-word structure, where the
REM  first word is the "next" pointer, the second word is a pointer to the
REM  copied string that is the identifier's name, and the third word is the 
REM  address the label points to.
CALL LABEL LABELS
  CALL DW 0
REM  Label name (to be copied) in AX. Address in BX.
CALL LABEL ADD_LABEL
  CALL PUSH AX
  CALL PUSH DI
  CALL CLL %STRDUP%
  CALL MOV DI AX
  CALL MOV AX WORD 6
  CALL CLL %ALLOC%
  CALL XCHG AX DI
  CALL MOV [DI+BYTE] 2 AX
  CALL MOV [DI+BYTE] 4 BX
  CALL MOV AX [WORD] %LABELS%
  CALL MOV [DI] AX
  CALL MOV [WORD] %LABELS% DI
  CALL POP DI
  CALL POP AX
  CALL RET

REM  Find a label whose name matches that in AX. Returns the address in AX.
REM  If not found, returns 0 in AX and sets CF.
CALL LABEL FIND_LABEL
  CALL PUSH DX
  CALL PUSH BX
  CALL PUSH SI
  CALL PUSH DI
  CALL MOV DX AX
  CALL MOV BX [WORD] %LABELS%
  CALL JMP %FIND_LABEL_LOOP%
  CALL LABEL FIND_LABEL_NEXT
  CALL MOV BX [BX]

  CALL LABEL FIND_LABEL_LOOP
  CALL TEST BX BX
  CALL JZ %FIND_LABEL_NONE%

  CALL MOV DI [BX+BYTE] 2
  CALL MOV SI DX
  CALL LABEL FIND_LABEL_SCAN
  CALL LODSB
  CALL SCASB
  CALL JNE %FIND_LABEL_NEXT%
  CALL TEST AL AL
  CALL JNZ %FIND_LABEL_SCAN%
  CALL MOV AX [BX+BYTE] 4
  CALL POP DI
  CALL POP SI
  CALL POP BX
  CALL POP DX
  CALL CLC
  CALL RET

  CALL LABEL FIND_LABEL_NONE
  CALL XOR AX AX
  CALL POP DI
  CALL POP SI
  CALL POP BX
  CALL POP DX
  CALL STC
  CALL RET

REM  An "ilabel" is a compiler-generated label that is indexed by a number and
REM  not a string. It has the same 3-word structure but the second word is the
REM  index.
CALL LABEL ILABELS
  CALL DW 0
REM  Index in AX, address in BX.
CALL LABEL ADD_ILABEL
  CALL PUSH AX
  CALL PUSH DI
  CALL MOV DI AX
  CALL MOV AX WORD 6
  CALL CLL %ALLOC%
  CALL XCHG AX DI
  CALL MOV [DI+BYTE] 2 AX
  CALL MOV [DI+BYTE] 4 BX
  CALL MOV AX [WORD] %ILABELS%
  CALL MOV [DI] AX
  CALL MOV [WORD] %ILABELS% DI
  CALL POP DI
  CALL POP AX
  CALL RET

REM  Index in AX. Returns address in AX. If not found, returns 0 in AX and
REM  sets CF.
CALL LABEL FIND_ILABEL
  CALL PUSH DX
  CALL PUSH BX
  CALL MOV DX AX
  CALL MOV BX [WORD] %ILABELS%
  CALL JMP %FIND_ILABEL_LOOP%
  CALL LABEL FIND_ILABEL_NEXT
  CALL MOV BX [BX]

  CALL LABEL FIND_ILABEL_LOOP
  CALL TEST BX BX
  CALL JZ %FIND_ILABEL_NONE%

  CALL CMP DX [BX+BYTE] 2
  CALL JNE %FIND_ILABEL_NEXT%

  CALL MOV AX [BX+BYTE] 4
  CALL POP BX
  CALL POP DX
  CALL CLC
  CALL RET

  CALL LABEL FIND_ILABEL_NONE
  CALL XOR AX AX
  CALL POP BX
  CALL POP DX
  CALL STC
  CALL RET

REM  This number is reset between passes so indices from the first pass
REM  exactly coincide with indices from the second pass.
CALL LABEL CUR_INDEX
  CALL DW 0
REM  Returns the new index in AX.
CALL LABEL NEXT_INDEX
  CALL MOV AX [WORD] %CUR_INDEX%
  CALL INC WORD [WORD] %CUR_INDEX%
  CALL RET

REM  A singly linked list of included files, to avoid including a file
REM  multiple times, if necessary. Consists of 2 words: next pointer, and
REM  pointer to copied string.
CALL LABEL INCLUDED
  CALL DW 0
REM  Checks if a string in AX is in the included list. Sets CF if so. If not,
REM  makes a copy of the string, makes a copy and adds it to the list. In any
REM  case it puts a pointer to the string in the list in AX.
CALL LABEL TEST_ADD_INCLUDED
  CALL PUSH DX
  CALL PUSH BX
  CALL PUSH SI
  CALL PUSH DI
  CALL MOV DX AX
  CALL MOV BX [WORD] %INCLUDED%
  CALL JMP %INCLUDED_LOOP%
  CALL LABEL INCLUDED_NEXT
  CALL MOV BX [BX]

  CALL LABEL INCLUDED_LOOP
  CALL TEST BX BX
  CALL JZ %INCLUDED_NONE%

  CALL MOV DI [BX+BYTE] 2
  CALL MOV SI DX
  CALL LABEL INCLUDED_SCAN
  CALL LODSB
  CALL SCASB
  CALL JNE %INCLUDED_NEXT%
  CALL TEST AL AL
  CALL JNZ %INCLUDED_SCAN%
  CALL MOV AX [BX+BYTE] 2
  CALL POP DI
  CALL POP SI
  CALL POP BX
  CALL POP DX
  CALL STC
  CALL RET

  CALL LABEL INCLUDED_NONE
  CALL MOV AX WORD 4
  CALL CLL %ALLOC%
  CALL MOV DI AX
  CALL MOV AX DX
  CALL CLL %STRDUP%
  CALL MOV [DI+BYTE] 2 AX
  CALL MOV DX [WORD] %INCLUDED%
  CALL MOV [DI] DX
  CALL MOV [WORD] %INCLUDED% DI
  CALL POP DI
  CALL POP SI
  CALL POP BX
  CALL POP DX
  CALL CLC
  CALL RET

REM  Parse an opened data block from the input handle, until EOF or closing
REM  bracket is encountered.
CALL LABEL READ_DATA_BLK
  CALL PUSH AX
  CALL PUSH CX
  CALL PUSH DX
  CALL PUSH BX
  CALL LABEL READ_DATA_LOOP
  CALL CLL %READ_TOKEN%
  CALL CMP AX WORD %TK_NUM%
  CALL JE %READ_DATA_NUM%
  CALL CMP AX WORD %TK_IDENT%
  CALL JE %READ_DATA_IDENT%
  CALL CMP AX WORD %TK_INCLUDE%
  CALL JE %READ_DATA_INCLUDE%
  CALL CMP AX BTW 36
  CALL JE %READ_DATA_DLR%
  CALL CMP AX BTW 0
  CALL JE %READ_DATA_END%
  CALL CMP AX BTW 93
  CALL JE %READ_DATA_END%
  CALL CLL %READ_COMMON%
  CALL JMP %READ_DATA_LOOP%

  CALL LABEL READ_DATA_END
  CALL POP BX
  CALL POP DX
  CALL POP CX
  CALL POP AX
  CALL RET
  
  CALL LABEL READ_DATA_NUM
  CALL MOV AX [WORD] %TOKEN_NUM%
  CALL CLL %EMIT_BYTE%
  CALL JMP %READ_DATA_LOOP%

  CALL LABEL READ_DATA_IDENT
  CALL MOV AX WORD %TOKEN_STR%
  CALL CLL %FIND_LABEL%
  CALL CLL %EMIT_BYTE%
  CALL JMP %READ_DATA_LOOP%

  CALL LABEL READ_DATA_INCLUDE
  CALL MOV AX WORD %TOKEN_STR%
  CALL CLL %TEST_ADD_INCLUDED%
  CALL CLL %INCLUDE_FILE%
  CALL JMP %READ_DATA_LOOP%

  CALL LABEL READ_DATA_DLR
  CALL CLL %READ_TOKEN%
  CALL CMP AX WORD %TK_NUM%
  CALL JE %READ_DATA_DLR_NUM%
  CALL CMP AX WORD %TK_IDENT%
  CALL JE %READ_DATA_DLR_IDENT%
  CALL CMP AX WORD %TK_INCLUDE%
  CALL JE %READ_DATA_DLR_INCLUDE%
  CALL CMP AX BTW 0
  CALL JE %READ_DATA_END%
  CALL CMP AX BTW 93
  CALL JE %READ_DATA_END%
  CALL CLL %READ_COMMON_DLR%
  CALL LABEL READ_DATA_DLR_END
  CALL JMP %READ_DATA_LOOP%

  CALL LABEL READ_DATA_DLR_NUM
  CALL MOV AX [WORD] %TOKEN_NUM%
  CALL CLL %EMIT_WORD%
  CALL JMP %READ_DATA_LOOP%

  CALL LABEL READ_DATA_DLR_IDENT
  CALL MOV AX WORD %TOKEN_STR%
  CALL CLL %FIND_LABEL%
  CALL CLL %EMIT_WORD%
  CALL JMP %READ_DATA_LOOP%

  CALL LABEL READ_DATA_DLR_INCLUDE
  CALL MOV AX WORD %TOKEN_STR%
  CALL CLL %TEST_ADD_INCLUDED%
  CALL JC %READ_DATA_DLR_END%
  CALL CLL %INCLUDE_FILE%
  CALL JMP %READ_DATA_DLR_END%

REM  Parse an opened text block from the input handle, until EOF or closing
REM  brace is encountered.
CALL LABEL READ_TEXT_BLK
  CALL PUSH AX
  CALL PUSH CX
  CALL PUSH DX
  CALL PUSH BX
  CALL LABEL READ_TEXT_LOOP
  CALL CLL %READ_TOKEN%
  CALL CMP AX WORD %TK_NUM%
  CALL JE %READ_TEXT_NUM%
  CALL CMP AX WORD %TK_IDENT%
  CALL JE %READ_TEXT_IDENT%
  CALL CMP AX WORD %TK_INCLUDE%
  CALL JE %READ_TEXT_INCLUDE%
  CALL CMP AX BTW 36
  CALL JE %READ_TEXT_DLR%
  CALL CMP AX BTW 0
  CALL JE %READ_TEXT_END%
  CALL CMP AX BTW 125
  CALL JE %READ_TEXT_END%
  CALL CLL %READ_COMMON%
  CALL JMP %READ_TEXT_LOOP%

  CALL LABEL READ_TEXT_END
  CALL POP BX
  CALL POP DX
  CALL POP CX
  CALL POP AX
  CALL RET
  
  CALL LABEL READ_TEXT_NUM
  CALL MOV AL BYTE 65464
  CALL CLL %EMIT_BYTE%
  CALL MOV AX [WORD] %TOKEN_NUM%
  CALL CLL %EMIT_WORD%
  CALL MOV AL BYTE 80
  CALL CLL %EMIT_BYTE%
  CALL JMP %READ_TEXT_LOOP%

  CALL LABEL READ_TEXT_IDENT
  CALL MOV AL BYTE 65512
  CALL CLL %EMIT_BYTE%
  CALL MOV AX WORD %TOKEN_STR%
  CALL CLL %FIND_LABEL%
  CALL SUB AX [WORD] %CUR_IP%
  CALL SUB AX BTW 2
  CALL CLL %EMIT_WORD%
  CALL JMP %READ_TEXT_LOOP%

  CALL LABEL READ_TEXT_INCLUDE
  CALL MOV AX WORD %TOKEN_STR%
  CALL CLL %TEST_ADD_INCLUDED%
  CALL CLL %INCLUDE_FILE%
  CALL JMP %READ_TEXT_LOOP%

  CALL LABEL READ_TEXT_DLR
  CALL CLL %READ_TOKEN%
  CALL CMP AX WORD %TK_NUM%
  CALL JE %READ_TEXT_DLR_NUM%
  CALL CMP AX WORD %TK_IDENT%
  CALL JE %READ_TEXT_DLR_IDENT%
  CALL CMP AX BTW 0
  CALL JE %READ_TEXT_END%
  CALL CMP AX BTW 125
  CALL JE %READ_TEXT_END%
  CALL CLL %READ_COMMON_DLR%
  CALL JMP %READ_TEXT_LOOP%

  CALL LABEL READ_TEXT_DLR_NUM
  CALL MOV AL BYTE 65535
  CALL CLL %EMIT_BYTE%
  CALL MOV AL BYTE 118
  CALL CLL %EMIT_BYTE%
  CALL MOV AX [WORD] %TOKEN_NUM%
  CALL ADD AL BYTE 2
  CALL SHL AL
  CALL CLL %EMIT_BYTE%
  CALL JMP NEAR %READ_TEXT_LOOP%

  CALL LABEL READ_TEXT_DLR_IDENT
  CALL MOV AL BYTE 65464
  CALL CLL %EMIT_BYTE%
  CALL MOV AX WORD %TOKEN_STR%
  CALL CLL %FIND_LABEL%
  CALL CLL %EMIT_WORD%
  CALL MOV AL BYTE 80
  CALL CLL %EMIT_BYTE%
  CALL JMP NEAR %READ_TEXT_LOOP%

CALL LABEL MOD_ARR
  CALL DB 89 51 65490 88 65527 65521 82
CALL EQU MOD_SZ 7

CALL LABEL AND_ARR
  CALL DB 88 89 35 65473 80
CALL EQU AND_SZ 5

CALL LABEL MUL_ARR
  CALL DB 88 90 65527 65506 80
CALL EQU MUL_SZ 5

CALL LABEL ADD_ARR
  CALL DB 88 89 3 65473 80
CALL EQU ADD_SZ 5

CALL LABEL DUP_ARR
  CALL DB 88 80 80
CALL EQU DUP_SZ 3

CALL LABEL SUB_ARR
  CALL DB 89 88 43 65473 80
CALL EQU SUB_SZ 5

CALL LABEL DIV_ARR
  CALL DB 89 51 65490 88 65527 65521 80
CALL EQU DIV_SZ 7

CALL LABEL FRM_PRO_ARR
  CALL DB 85 65417 65509 65411 65516
CALL EQU FRM_PRO_SZ 5

CALL LABEL FRM_EPI_ARR
  CALL DB 65417 65516 93 65475
CALL EQU FRM_EPI_SZ 4

CALL LABEL LT_ARR
  CALL DB 89 88 51 65490 59 65473 115 1
  CALL DB 66 82
CALL EQU LT_SZ 10

CALL LABEL EQ_ARR
  CALL DB 88 89 51 65490 59 65473 117 1
  CALL DB 66 82
CALL EQU EQ_SZ 10

CALL LABEL XOR_ARR
  CALL DB 88 89 51 65473 80
CALL EQU XOR_SZ 5

CALL LABEL NEG_ARR
  CALL DB 88 65527 65496 80
CALL EQU NEG_SZ 4

CALL LABEL OR_ARR
  CALL DB 88 89 11 65473 80
CALL EQU OR_SZ 5

CALL LABEL NOT_ARR
  CALL DB 88 65527 65488 80
CALL EQU NOT_SZ 4

CALL LABEL READ_COMMON
REM  This function is too long for 8-bit displacements so the "jumptable" has
REM  to be split into two pieces: READ_C1 and READ_C2.
  CALL JMP NEAR %READ_C1%

  CALL LABEL READ_C_MOD
  CALL MOV AX WORD %MOD_ARR%
  CALL MOV CX WORD %MOD_SZ%
  CALL CLL %EMIT_ARRAY%
  CALL RET

  CALL LABEL READ_C_AND
  CALL MOV AX WORD %AND_ARR%
  CALL MOV CX WORD %AND_SZ%
  CALL CLL %EMIT_ARRAY%
  CALL RET

  CALL LABEL READ_C_MUL
  CALL MOV AX WORD %MUL_ARR%
  CALL MOV CX WORD %MUL_SZ%
  CALL CLL %EMIT_ARRAY%
  CALL RET

  CALL LABEL READ_C_ADD
  CALL MOV AX WORD %ADD_ARR%
  CALL MOV CX WORD %ADD_SZ%
  CALL CLL %EMIT_ARRAY%
  CALL RET

  CALL LABEL READ_C_DUP
  CALL MOV AX WORD %DUP_ARR%
  CALL MOV CX WORD %DUP_SZ%
  CALL CLL %EMIT_ARRAY%
  CALL RET

  CALL LABEL READ_C_SUB
  CALL MOV AX WORD %SUB_ARR%
  CALL MOV CX WORD %SUB_SZ%
  CALL CLL %EMIT_ARRAY%
  CALL RET

  CALL LABEL READ_C_POP
  CALL MOV AL BYTE 88
  CALL CLL %EMIT_BYTE%
  CALL RET

  CALL LABEL READ_C_DIV
  CALL MOV AX WORD %DIV_ARR%
  CALL MOV CX WORD %DIV_SZ%
  CALL CLL %EMIT_ARRAY%
  CALL RET

  CALL LABEL READ_C1
  CALL CMP AX BTW 37
  CALL JE %READ_C_MOD%
  CALL CMP AX BTW 38
  CALL JE %READ_C_AND%
  CALL CMP AX BTW 42
  CALL JE %READ_C_MUL%
  CALL CMP AX BTW 43
  CALL JE %READ_C_ADD%
  CALL CMP AX BTW 44
  CALL JE %READ_C_DUP%
  CALL CMP AX BTW 45
  CALL JE %READ_C_SUB%
  CALL CMP AX BTW 46
  CALL JE %READ_C_POP%
  CALL CMP AX BTW 47
  CALL JE %READ_C_DIV%
  CALL CMP AX BTW 58
  CALL JE %READ_C_COLON%
  CALL CMP AX BTW 60
  CALL JE %READ_C_LT%
  CALL CMP AX BTW 61
  CALL JE %READ_C_EQ%
  CALL CMP AX BTW 64
  CALL JE %READ_C_AT%
  CALL CMP AX BTW 94
  CALL JMP NEAR %READ_C2%

  CALL LABEL READ_C_COLON
  CALL CLL %READ_TOKEN%
  CALL CMP AX WORD %TK_IDENT%
  CALL JE %READ_C_LBL%
  CALL CMP AX WORD %TK_NUM%
  CALL JE %READ_C_FRM%
  CALL RET
  
  CALL LABEL READ_C_LBL
  CALL MOV AX WORD %TOKEN_STR%
  CALL CLL %FIND_LABEL%
  CALL JNC %READ_C_RET%
  CALL MOV AX WORD %TOKEN_STR%
  CALL MOV BX [WORD] %CUR_IP%
  CALL CLL %ADD_LABEL%
  CALL LABEL READ_C_RET
  CALL RET

  CALL LABEL READ_C_FRM
  CALL MOV AX WORD %FRM_PRO_ARR%
  CALL MOV CX WORD %FRM_PRO_SZ%
  CALL CLL %EMIT_ARRAY%
  CALL MOV AX [WORD] %TOKEN_NUM%
  CALL SHL AL
  CALL CLL %EMIT_BYTE%
  CALL CLL %READ_TOKEN%
  CALL CMP AX BTW 123
  CALL JNE %READ_C_RET%
  CALL CLL %READ_TEXT_BLK%
  CALL MOV AX WORD %FRM_EPI_ARR%
  CALL MOV CX WORD %FRM_EPI_SZ%
  CALL CLL %EMIT_ARRAY%
  CALL RET

  CALL LABEL READ_C_LT
  CALL MOV AX WORD %LT_ARR%
  CALL MOV CX WORD %LT_SZ%
  CALL CLL %EMIT_ARRAY%
  CALL RET

  CALL LABEL READ_C_EQ
  CALL MOV AX WORD %EQ_ARR%
  CALL MOV CX WORD %EQ_SZ%
  CALL CLL %EMIT_ARRAY%
  CALL RET

  CALL LABEL READ_C_AT
  CALL CLL %READ_TOKEN%
  CALL CMP AX BTW 61
  CALL JE %READ_C_TOLOC%
  CALL CMP AX WORD %TK_NUM%
  CALL JE %READ_C_LOC%
  CALL CMP AX WORD %TK_IDENT%
  CALL JE %READ_C_GOTO%
  CALL RET

  CALL LABEL READ_C_TOLOC
  CALL CLL %READ_TOKEN%
  CALL CMP AX WORD %TK_NUM%
  CALL JNE %READ_C_RET2%
  CALL MOV AL BYTE 65423
  CALL CLL %EMIT_BYTE%
  CALL MOV AL BYTE 70
  CALL CLL %EMIT_BYTE%
  CALL MOV AX [WORD] %TOKEN_NUM%
  CALL NOT AL
  CALL SHL AL
  CALL CLL %EMIT_BYTE%
  CALL LABEL READ_C_RET2
  CALL RET
  
  CALL LABEL READ_C_LOC
  CALL MOV AL BYTE 65535
  CALL CLL %EMIT_BYTE%
  CALL MOV AL BYTE 118
  CALL CLL %EMIT_BYTE%
  CALL MOV AX [WORD] %TOKEN_NUM%
  CALL NOT AL
  CALL SHL AL
  CALL CLL %EMIT_BYTE%
  CALL RET

  CALL LABEL READ_C_GOTO
  CALL MOV AL BYTE 65513
  CALL CLL %EMIT_BYTE%
  CALL MOV AX WORD %TOKEN_STR%
  CALL CLL %FIND_LABEL%
  CALL SUB AX [WORD] %CUR_IP%
  CALL SUB AX BTW 2
  CALL CLL %EMIT_WORD%
  CALL RET

  CALL LABEL READ_C_XOR
  CALL MOV AX WORD %XOR_ARR%
  CALL MOV CX WORD %XOR_SZ%
  CALL CLL %EMIT_ARRAY%
  CALL RET

  CALL LABEL READ_C_NEG
  CALL MOV AX WORD %NEG_ARR%
  CALL MOV CX WORD %NEG_SZ%
  CALL CLL %EMIT_ARRAY%
  CALL RET

  CALL LABEL READ_C_OR
  CALL MOV AX WORD %OR_ARR%
  CALL MOV CX WORD %OR_SZ%
  CALL CLL %EMIT_ARRAY%
  CALL RET

  CALL LABEL READ_C_NOT
  CALL MOV AX WORD %NOT_ARR%
  CALL MOV CX WORD %NOT_SZ%
  CALL CLL %EMIT_ARRAY%
  CALL RET

  CALL LABEL READ_C_DATA
  CALL JMP NEAR %READ_DATA_BLK%

  CALL LABEL READ_C_TEXT
  CALL JMP NEAR %READ_TEXT_BLK%

  CALL LABEL READ_C2
  CALL JE %READ_C_XOR%
  CALL CMP AX BTW 96
  CALL JE %READ_C_NEG%
  CALL CMP AX BTW 124
  CALL JE %READ_C_OR%
  CALL CMP AX BTW 126
  CALL JE %READ_C_NOT%
  CALL CMP AX BTW 91
  CALL JE %READ_C_DATA%
  CALL CMP AX BTW 123
  CALL JE %READ_C_TEXT%
  CALL RET

CALL LABEL WW_ARR
  CALL DB 91 88 65417 7
CALL EQU WW_SZ 4

CALL LABEL WB_ARR
  CALL DB 91 88 65416 7
CALL EQU WB_SZ 4

CALL LABEL RB_ARR
  CALL DB 91 65418 31 50 65535 83
CALL EQU RB_SZ 6

CALL LABEL RW_ARR
  CALL DB 91 65535 55
CALL EQU RW_SZ 3

CALL LABEL SRET_ARR
  CALL DB 65419 70 2 65415 70 0 65415 70
  CALL DB 65534 65417 70 2 65411 65517 2
CALL EQU SRET_SZ 15

CALL LABEL SARG_ARR
  CALL DB 65411 65477 2 65419 70 2 65415 70
  CALL DB 65534 65415 70 0 65417 70 2
CALL EQU SARG_SZ 15

CALL LABEL COND_ARR
  CALL DB 88 65413 65472 116
CALL EQU COND_SZ 4

CALL LABEL READ_COMMON_DLR
REM  Not quite as severe as in READ_COMMON, but we still have to place the
REM  jumptable in the middle of the branches.
  CALL JMP NEAR %READ_D%

  CALL LABEL READ_D_SKIP
  CALL CLL %READ_TOKEN%
  CALL CMP AX BTW 123
  CALL JNE %READ_D_RET%
  CALL CLL %NEXT_INDEX%
  CALL MOV BX AX
  CALL MOV AL BYTE 65513
  CALL CLL %EMIT_BYTE%
  CALL MOV AX BX
  CALL CLL %FIND_ILABEL%
  CALL SUB AX [WORD] %CUR_IP%
  CALL SUB AX BTW 2
  CALL CLL %EMIT_WORD%
  CALL CLL %READ_TEXT_BLK%
  CALL MOV AX BX
  CALL MOV BX [WORD] %CUR_IP%
  CALL CLL %ADD_ILABEL%
  CALL LABEL READ_D_RET
  CALL RET

  CALL LABEL READ_D_WW
  CALL MOV AX WORD %WW_ARR%
  CALL MOV CX WORD %WW_SZ%
  CALL CLL %EMIT_ARRAY%
  CALL RET

  CALL LABEL READ_D_WB
  CALL MOV AX WORD %WB_ARR%
  CALL MOV CX WORD %WB_SZ%
  CALL CLL %EMIT_ARRAY%
  CALL RET

  CALL LABEL READ_D_RB
  CALL MOV AX WORD %RB_ARR%
  CALL MOV CX WORD %RB_SZ%
  CALL CLL %EMIT_ARRAY%
  CALL RET

  CALL LABEL READ_D_RW
  CALL MOV AX WORD %RW_ARR%
  CALL MOV CX WORD %RW_SZ%
  CALL CLL %EMIT_ARRAY%
  CALL RET

  CALL LABEL READ_D_SRET
  CALL MOV AX WORD %SRET_ARR%
  CALL MOV CX WORD %SRET_SZ%
  CALL CLL %EMIT_ARRAY%
  CALL RET

  CALL LABEL READ_D_SARG
  CALL MOV AX WORD %SARG_ARR%
  CALL MOV CX WORD %SARG_SZ%
  CALL CLL %EMIT_ARRAY%
  CALL RET

  CALL LABEL READ_D
  CALL CMP AX BTW 36
  CALL JE %READ_D_SKIP%
  CALL CMP AX BTW 42
  CALL JE %READ_D_WW%
  CALL CMP AX BTW 43
  CALL JE %READ_D_WB%
  CALL CMP AX BTW 45
  CALL JE %READ_D_RB%
  CALL CMP AX BTW 47
  CALL JE %READ_D_RW%
  CALL CMP AX BTW 58
  CALL JE %READ_D_SRET%
  CALL CMP AX BTW 59
  CALL JE %READ_D_SARG%
  CALL CMP AX BTW 61
  CALL JE %READ_D_TOIDENT%
  CALL CMP AX BTW 63
  CALL JE %READ_D_IF%
  CALL CMP AX BTW 64
  CALL JE %READ_D_WHILE%
  CALL RET

  CALL LABEL READ_D_TOIDENT
  CALL CLL %READ_TOKEN%
  CALL CMP AX WORD %TK_IDENT%
  CALL JNE %READ_D_RET2%
  CALL MOV AL BYTE 65423
  CALL CLL %EMIT_BYTE%
  CALL MOV AL BYTE 6
  CALL CLL %EMIT_BYTE%
  CALL MOV AX WORD %TOKEN_STR%
  CALL CLL %FIND_LABEL%
  CALL CLL %EMIT_WORD%
  CALL RET

  CALL LABEL READ_D_IF
  CALL CLL %READ_TOKEN%
  CALL CMP AX BTW 123
  CALL JNE %READ_D_RET2%
  CALL CLL %NEXT_INDEX%
  CALL MOV BX AX
  CALL CLL %NEXT_INDEX%
  CALL MOV DX AX
  CALL MOV AX WORD %COND_ARR%
  CALL MOV CX WORD %COND_SZ%
  CALL CLL %EMIT_ARRAY%
  CALL MOV AX BX
  CALL CLL %FIND_ILABEL%
  CALL SUB AX [WORD] %CUR_IP%
  CALL DEC AX
  CALL CLL %EMIT_BYTE%
  CALL CLL %READ_TEXT_BLK%
  CALL MOV AL BYTE 65515
  CALL CLL %EMIT_BYTE%
  CALL MOV AX DX
  CALL CLL %FIND_ILABEL%
  CALL SUB AX [WORD] %CUR_IP%
  CALL DEC AX
  CALL CLL %EMIT_BYTE%
  CALL MOV AX BX
  CALL MOV BX [WORD] %CUR_IP%
  CALL CLL %ADD_ILABEL%
  CALL CLL %READ_TOKEN%
  CALL CMP AX BTW 123
  CALL JNE %READ_D_RET2%
  CALL CLL %READ_TEXT_BLK%
  CALL MOV AX DX
  CALL MOV BX [WORD] %CUR_IP%
  CALL CLL %ADD_ILABEL%
  CALL LABEL READ_D_RET2
  CALL RET

  CALL LABEL READ_D_WHILE
  CALL CLL %READ_TOKEN%
  CALL CMP AX BTW 123
  CALL JNE %READ_D_RET2%
  CALL CLL %NEXT_INDEX%
  CALL MOV CX AX
  CALL CLL %NEXT_INDEX%
  CALL MOV DX AX
  CALL MOV AX CX
  CALL MOV BX [WORD] %CUR_IP%
  CALL CLL %ADD_ILABEL%
  CALL CLL %READ_TEXT_BLK%
  CALL MOV AX WORD %COND_ARR%
  CALL MOV BX CX
  CALL MOV CX WORD %COND_SZ%
  CALL CLL %EMIT_ARRAY%
  CALL MOV AX DX
  CALL CLL %FIND_ILABEL%
  CALL SUB AX [WORD] %CUR_IP%
  CALL DEC AX
  CALL CLL %EMIT_BYTE%
  CALL CLL %READ_TOKEN%
  CALL CMP AX BTW 123
  CALL JNE %READ_D_RET2%
  CALL CLL %READ_TEXT_BLK%
  CALL MOV AL BYTE 65515
  CALL CLL %EMIT_BYTE%
  CALL MOV AX BX
  CALL CLL %FIND_ILABEL%
  CALL SUB AX [WORD] %CUR_IP%
  CALL DEC AX
  CALL CLL %EMIT_BYTE%
  CALL MOV AX DX
  CALL MOV BX [WORD] %CUR_IP%
  CALL CLL %ADD_ILABEL%
  CALL RET

REM  Process an include directive (filename in AX).
CALL LABEL INCLUDE_FILE
  CALL PUSH [WORD] %IN_HANDLE%
  CALL PUSH [WORD] %IN_NAME_PTR%
  CALL MOV [WORD] 0%IN_NAME_PTR% AX
  CALL CLL %PROCESS_FILE%
  CALL POP [WORD] %IN_NAME_PTR%
  CALL POP [WORD] %IN_HANDLE%
  CALL RET

REM  Open a file whose name is in IN_NAME_PTR, do a single pass over its
REM  contents, and close the file.
CALL LABEL PROCESS_FILE
REM  Open the input file.
  CALL PUSH AX
  CALL PUSH DX
  CALL PUSH BX
  CALL MOV AX [WORD] %IN_NAME_PTR%
  CALL CLL %TEST_ADD_INCLUDED%
  CALL MOV DX [WORD] %IN_NAME_PTR%
  CALL XOR AL AL
  CALL MOV AH BYTE 61
  CALL INT 33
  CALL CLL %JC_PANIC%
  CALL MOV [WORD] %IN_HANDLE% AX
REM  Do the pass.
  CALL CLL %READ_DATA_BLK%
REM  Close the input file.
  CALL MOV BX [WORD] %IN_HANDLE%
  CALL MOV AH BYTE 62
  CALL INT 33
  CALL CLL %JC_PANIC%
  CALL POP BX
  CALL POP DX
  CALL POP AX
  CALL RET

CALL LABEL IN_NAME_PTR
  CALL DW 0
CALL LABEL OUT_NAME_PTR
  CALL DW 0
CALL LABEL MAIN
REM  Separate two arguments by spaces.
  CALL MOV SI WORD 130
  CALL MOV [WORD] %IN_NAME_PTR% SI
  CALL LABEL MAIN_PARSE_IN
  CALL LODSB
  CALL CMP AL BYTE 13
  CALL CLL %JE_PANIC%
  CALL CMP AL BYTE 32
  CALL JNE %MAIN_PARSE_IN%
  CALL MOV [SI+BYTE] 65535 BYTE 0
  CALL MOV [WORD] %OUT_NAME_PTR% SI
  CALL LABEL MAIN_PARSE_OUT
  CALL LODSB
  CALL CMP AL BYTE 32
  CALL CLL %JE_PANIC%
  CALL CMP AL BYTE 13
  CALL JNE %MAIN_PARSE_OUT%
  CALL MOV [SI+BYTE] 65535 BYTE 0

REM  Create or truncate the output file.
  CALL MOV DX [WORD] %OUT_NAME_PTR%
  CALL XOR CX CX
  CALL MOV AH BYTE 60
  CALL INT 33
  CALL CLL %JC_PANIC%
  CALL MOV [WORD] %OUT_HANDLE% AX

REM  Do the first pass to calculate the addresses of all the labels.
  CALL MOV [WORD] %EMIT_MODE% BYTE 0 
  CALL MOV [WORD] %CUR_IP% WORD 256
  CALL MOV [WORD] %CUR_INDEX% WORD 0
  CALL CLL %PROCESS_FILE%

REM  Do the second pass to emit all the bytes.
  CALL MOV [WORD] %EMIT_MODE% BYTE 1
  CALL MOV [WORD] %CUR_IP% WORD 256
  CALL MOV [WORD] %CUR_INDEX% WORD 0
  CALL MOV [WORD] %INCLUDED% WORD 0
  CALL CLL %PROCESS_FILE%

REM  Close the output file.
  CALL MOV BX [WORD] %OUT_HANDLE%
  CALL MOV AH BYTE 62
  CALL INT 33
  CALL CLL %JC_PANIC%
  
  CALL RET

CALL LABEL HEAPSTART

